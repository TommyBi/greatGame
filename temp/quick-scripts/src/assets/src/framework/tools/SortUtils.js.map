{"version":3,"sources":["assets/src/framework/tools/SortUtils.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["//排序算法集合\r\nexport default class SortUtils {\r\n\r\n    /**\r\n     * 冒泡排序算法\r\n     * @param collects \r\n     * @param key 如果是对象则使用key值进行比较\r\n     * @returns \r\n     */\r\n    static bubbleSort<T>(collects: Array<T>, key?: string): Array<T> {\r\n        let isNeedKey: boolean = !!key;\r\n        if (collects) {\r\n            let len = collects.length;\r\n            for (let i = 0; i < len - 1; i++) {\r\n                let flag: boolean = true;//优化 如果一轮检查下来发现没有可交换的 说明已经是有序的，不用再检查了\r\n                let frist = null;//前一个需要比较值\r\n                let next = null;//后一个需要比较的值\r\n                for (let j = 0; j < len - i - 1; j++) {\r\n                    if (isNeedKey) {//是否是对象需要排序\r\n                        frist = collects[j][key];\r\n                        next = collects[j + 1][key];\r\n                    } else {\r\n                        frist = collects[j];\r\n                        next = collects[j + 1];\r\n                    }\r\n\r\n                    if (frist < next) {\r\n                        //进行交换\r\n                        let temp = collects[j + 1];\r\n                        collects[j + 1] = collects[j];\r\n                        collects[j] = temp;\r\n                        flag = false;\r\n                    }\r\n                }\r\n                // console.log(i + \"执行了多少次\");\r\n                if (flag) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n        }\r\n        return collects;\r\n    }\r\n\r\n    /**\r\n     * 希尔排序\r\n     * @param collects \r\n     * @param key \r\n     * @returns \r\n     */\r\n    static shellSort<T>(collects: Array<T>, key?: string): Array<T> {\r\n        let len = collects.length;\r\n\r\n        return collects;\r\n    }\r\n\r\n    private static insertArr() {\r\n\r\n    }\r\n\r\n    /**\r\n     * 插入排序算法\r\n     * @param collects 需要排序的集合\r\n     * @param key 如果是对象需要排序，需要提供一个key 来获取number类型的值进行排序\r\n     * @returns 返回一个排序好的数组\r\n     */\r\n    static insertSort<T>(collects: Array<T>, key?: string): Array<T> {\r\n        if (!collects || collects.length < 2) {\r\n\r\n            return collects;\r\n        }\r\n        let isNeedKey: boolean = !!key;\r\n        let preElement = null;//前一个元素\r\n        let nextElement = null;//后一个元素\r\n\r\n        for (let index = 1; index < collects.length; index++) {\r\n            preElement = isNeedKey ? collects[index - 1][key] : collects[index - 1];\r\n            nextElement = isNeedKey ? collects[index][key] : collects[index];\r\n            if (preElement > nextElement) {\r\n\r\n                //TODO 优化思考\r\n                let i = index;\r\n                //排序之前的元素\r\n                for (i; i > 0; i--) {\r\n                    const cValue = isNeedKey ? collects[i][key] : collects[i];\r\n                    const cPre = isNeedKey ? collects[i - 1][key] : collects[i - 1];\r\n                    if (cValue < cPre) {\r\n                        let temp = collects[i];\r\n                        collects[i] = collects[i - 1];\r\n                        collects[i - 1] = temp;\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        return collects;\r\n    }\r\n\r\n    // /**\r\n    //  * 通过二分法查找 因为对于当前元素前边都是已经排序好的，通过二分法减少查看次数\r\n    //  * @param collects \r\n    //  * @param key \r\n    //  * @param index   collects 中已经检查到的索引\r\n    //  * @returns \r\n    //  */\r\n    // private static insertFindBinary<T>(collects:Array<T>,key:string,index:number):number\r\n    // {\r\n    //     let isNeedKey:boolean = !!key;\r\n\r\n    //     let midIndex:number = Math.floor( index/2 );\r\n    //     let needValue = isNeedKey ? collects[index][key] : collects[index];//需要比较的当前值\r\n    //     while(true)\r\n    //     {\r\n    //         const mValue =  isNeedKey ? collects[midIndex][key] : collects[midIndex];\r\n    //         if (needValue > mValue) {\r\n    //             midIndex = Math.floor( midIndex / 2 );\r\n    //         } else if (mValue == needValue) {\r\n    //             return midIndex;\r\n    //         } else {\r\n    //             midIndex = Math.floor( (index - midIndex) / 2 );\r\n    //         }\r\n    //         if (midIndex <= 0) {\r\n    //             break;\r\n    //         }\r\n    //     }\r\n\r\n    //     return index;\r\n    // }\r\n\r\n    /**\r\n     * 快速排序\r\n     * @param collects 需要排序的集合\r\n     * @param key 如果是对象的话，需要按照key进行\r\n     * @isBig 是否是从大到小排序\r\n     * @returns 返回排序好的集合\r\n     */\r\n    static quickSort<T>(collects: Array<T>, isBig = true, key?: string): Array<T> {\r\n        SortUtils.quickSortHandle(collects, 0, collects.length - 1, key);\r\n        return collects;\r\n    }\r\n\r\n    /**\r\n     * 快速排序的逻辑\r\n     * @param collects 排序的集合\r\n     * @param start 开始位置\r\n     * @param end   结束位置\r\n     * @param key   如果是对象进行排序 需要用到的key obj[key] is number\r\n     * @returns \r\n     */\r\n    private static quickSortHandle<T>(collects: Array<T>, start: number, end: number, key?: string, isBig = true): void {\r\n        if (start >= end) {\r\n            return;\r\n        }\r\n\r\n        let isNeedKey: boolean = !!key;//是否需要根据key 进行排序\r\n        let mindex: number = start;//Math.floor( (end - start)/2 );//取第一个值或者中间的值\r\n        let midValue = isNeedKey ? collects[mindex][key] : collects[mindex];\r\n        let midOrg = collects[mindex];//中间的原始值\r\n        let i = start;\r\n        let j = end;\r\n\r\n        while (i < j) {\r\n            //找到右侧比基准值小的 索引 同时暂停右侧的查询，执行左侧的查询，找到比基准值大把当前j索引的值替换掉，防止数值重复\r\n            let currValue = isNeedKey ? collects[j][key] : collects[j];\r\n            if (isBig) {\r\n\r\n                while (i < j && currValue < midValue) {\r\n                    j--;\r\n                    currValue = isNeedKey ? collects[j][key] : collects[j];\r\n                }\r\n            } else {\r\n\r\n                while (i < j && currValue > midValue) {\r\n                    j--;\r\n                    currValue = isNeedKey ? collects[j][key] : collects[j];\r\n                }\r\n            }\r\n\r\n            //把右侧的大的值赋给左侧\r\n            if (i < j) {\r\n                collects[i] = collects[j];\r\n                i++;\r\n            }\r\n\r\n            currValue = isNeedKey ? collects[i][key] : collects[i];\r\n            while (i < j && currValue < midValue) {\r\n                i++;\r\n                currValue = isNeedKey ? collects[i][key] : collects[i];\r\n            }\r\n\r\n            if (i < j) {\r\n                collects[j] = collects[i];\r\n                j--;\r\n            }\r\n\r\n        }\r\n        collects[i] = midOrg;\r\n        SortUtils.quickSortHandle(collects, start, i - 1, key);\r\n        SortUtils.quickSortHandle(collects, i + 1, end, key);\r\n    }\r\n    /**\r\n     * 快速排序\r\n     * @param collects 需要排序的集合\r\n     * @param key 如果是对象的话，需要按照key进行\r\n     * @returns 返回排序好的集合\r\n     */\r\n    static quickSortNode<T>(collects: Array<T>, key?: string): Array<T> {\r\n        SortUtils.quickSortHandle(collects, 0, collects.length - 1, key);\r\n        return collects;\r\n    }\r\n    /**\r\n     * 快速排序的逻辑\r\n     * @param collects 排序的集合\r\n     * @param start 开始位置\r\n     * @param end   结束位置\r\n     * @param key   如果是对象进行排序 需要用到的key obj[key] is number\r\n     * @returns \r\n     */\r\n    private static quickSortNodeHandler<T>(collects: Array<T>, start: number, end: number, key?: string): void {\r\n        if (start >= end) {\r\n            return;\r\n        }\r\n\r\n        let isNeedKey: boolean = !!key;//是否需要根据key 进行排序\r\n        let mindex: number = start;//Math.floor( (end - start)/2 );//取第一个值或者中间的值\r\n        let midValue = isNeedKey ? collects[mindex][key] : collects[mindex];\r\n        let midOrg = collects[mindex];//中间的原始值\r\n        let i = start;\r\n        let j = end;\r\n\r\n        while (i < j) {\r\n            //找到右侧比基准值小的 索引 同时暂停右侧的查询，执行左侧的查询，找到比基准值大把当前j索引的值替换掉，防止数值重复\r\n            let currValue = isNeedKey ? collects[j][key] : collects[j];\r\n            while (i < j && currValue > midValue) {\r\n                j--;\r\n                currValue = isNeedKey ? collects[j][key] : collects[j];\r\n            }\r\n\r\n            //把右侧的大的值赋给左侧\r\n            if (i < j) {\r\n                collects[i] = collects[j];\r\n                i++;\r\n            }\r\n\r\n            currValue = isNeedKey ? collects[i][key] : collects[i];\r\n            while (i < j && currValue < midValue) {\r\n                i++;\r\n                currValue = isNeedKey ? collects[i][key] : collects[i];\r\n            }\r\n\r\n            if (i < j) {\r\n                collects[j] = collects[i];\r\n                j--;\r\n            }\r\n\r\n        }\r\n        collects[i] = midOrg;\r\n        SortUtils.quickSortHandle(collects, start, i - 1, key);\r\n        SortUtils.quickSortHandle(collects, i + 1, end, key);\r\n    }\r\n\r\n\r\n}"]}